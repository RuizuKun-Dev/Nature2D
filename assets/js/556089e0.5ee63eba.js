"use strict";(self.webpackChunknature_2_d_docs=self.webpackChunknature_2_d_docs||[]).push([[246],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),h=o,f=p["".concat(l,".").concat(h)]||p[h]||u[h]||r;return n?i.createElement(f,a(a({ref:t},c),{},{components:n})):i.createElement(f,a({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var d=2;d<r;d++)a[d]=n[d];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8788:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return c},default:function(){return p}});var i=n(7462),o=n(3366),r=(n(7294),n(3905)),a=["components"],s={sidebar_position:3},l="Conceptual Understanding",d={unversionedId:"works",id:"works",isDocsHomePage:!1,title:"Conceptual Understanding",description:"Before diving into the api, it is important to know how the library really comes together and do what its supposed to do. The library uses methods of Verlet Integration and Convex Hull Collisions (Separating Axis Theorem) to simulate physics. I have detailed the math and working of both of those methods on the Devforum and Github with code snippets! If you'd want to explore more about them, go through the following links!",source:"@site/docs/works.md",sourceDirName:".",slug:"/works",permalink:"/Nature2D/docs/works",editUrl:"https://github.com/jaipack17/Nature2D/edit/master/docs/docs/works.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/Nature2D/docs/installation"},next:{title:"Creating RigidBodies",permalink:"/Nature2D/docs/tutorial-basics/Creating RigidBodies"}},c=[{value:"Engine",id:"engine",children:[],level:2},{value:"Point",id:"point",children:[],level:2},{value:"Constraint",id:"constraint",children:[],level:2},{value:"RigidBody",id:"rigidbody",children:[],level:2}],u={toc:c};function p(e){var t=e.components,n=(0,o.Z)(e,a);return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"conceptual-understanding"},"Conceptual Understanding"),(0,r.kt)("p",null,"Before diving into the api, it is important to know how the library really comes together and do what its supposed to do. The library uses methods of ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Verlet_integration"},"Verlet Integration")," and Convex Hull Collisions (Separating Axis Theorem) to simulate physics. I have detailed the math and working of both of those methods on the Devforum and Github with code snippets! If you'd want to explore more about them, go through the following links!"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://devforum.roblox.com/t/the-beauty-of-verlet-integration-2d-ragdolls/1467651/"},"Verlet Integration")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://devforum.roblox.com/t/detecting-and-responding-to-2d-collisions-fundamentals-techniques/1484368"},"2D Collisions"))),(0,r.kt)("p",null,"Back to Nature2D. The library is divided into different segments. The core, which is the Engine. The physics based classes, which are the RigidBodies, Constraints and Points, utilities which consists of non inclusive modules to help render constraints and points on the screen and global constant values."),(0,r.kt)("h2",{id:"engine"},"Engine"),(0,r.kt)("p",null,"The Engine or the core of the library handles all the RigidBodies, constraints and points. It's responsible for the simulation of these elements and handling all tasks related to the library. Physics is simulated at a fixed rate of 60hz with the following structure of tasks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Update rigid bodies."),(0,r.kt)("li",{parentName:"ul"},"Detect rigid body collisions.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Process collision response with given number of collision iterations."))),(0,r.kt)("li",{parentName:"ul"},"Update points."),(0,r.kt)("li",{parentName:"ul"},"Update constraints."),(0,r.kt)("li",{parentName:"ul"},"Render rigid bodies."),(0,r.kt)("li",{parentName:"ul"},"Render points."),(0,r.kt)("li",{parentName:"ul"},"Render constraints.")),(0,r.kt)("h2",{id:"point"},"Point"),(0,r.kt)("p",null,"Points are what make the rigid bodies behave like real world entities! Points are responsible for the movement of the RigidBodies and Constraints! These points have a velocity and acceleration that make them move around a canvas! These points are not rendered on the screen by default and it is advisable to keep it that way. Points don't need to be created manually unless creating custom Constraints. By default points are handled by the core (Engine) itself!"),(0,r.kt)("h2",{id:"constraint"},"Constraint"),(0,r.kt)("p",null,"Constraints keep two points together in place and maintain uniform distance between the two! Constraints and Points together join to keep a RigidBody in place hence making both Points and Constraints a vital part of the library. Custom constraints such as Ropes, Rods, Bridges and chains can also be made! Points of two rigid bodies can be connected with constraints, two individual points can also be connected with constraints to form Ropes etc. Nature2D supports 3 kinds of constraints as of now - Ropes, Rods and Springs."),(0,r.kt)("h2",{id:"rigidbody"},"RigidBody"),(0,r.kt)("p",null,"RigidBodies are formed by Constraints, Points and UI Elements! These RigidBodies are highly flexible to meet all your use cases! RigidBodies can be customized and custom physical properties can be defined for them. By default they abide by the universal physical properties of the engine."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"This introduction should give you a brief understanding of how everything works. Continue reading furthur by clicking links above or exploring the API, examples and placefiles!"))}p.isMDXComponent=!0}}]);